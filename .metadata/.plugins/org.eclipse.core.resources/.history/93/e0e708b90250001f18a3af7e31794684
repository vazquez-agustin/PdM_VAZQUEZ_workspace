/*
 * API_display.c
 *
 *  Created on: Jul 29, 2024
 *      Author: ubuntu
 */

/* Includes ------------------------------------------------------------------*/

#include "API_display.h"
#include "API_display_HAL.h"

typedef enum {
	false = 0, true
} bool_t;

/* Private define ------------------------------------------------------------*/

#define CLEARdISPLAY 0x01 // Comando para limpiar la pantalla
#define NIBBLEmODE 0x28   // Configurar LCD en 4 bits, 2 líneas, 5x7 puntos
#define EIGHTbITSmODE 0x30 // Configurar LCD en 8 bits
#define FOURbITSmODE 0x20 // Configurar LCD en 4 bits
#define DISPLAYoFF 0x08  // Apaga el display
#define CURSORrIGHT 0x06  // Mueve el cursor a la derecha por cada escritura
#define DISPLAYwITHOUTcURSOR 0x0C  //Enciende el display, sin cursor

#define LINE1aDDR 0x00
#define LINE2aDDR 0x40

// Dirección I2C del expansor de I/O PCF8574
#define LCD_CMD 0
#define LCD_DATA 1

// Definition of specific bits
#define LCD_ENABLE 0x04
#define LCD_RS 0x01
#define LCD_RW 0x02

static void API_display_writeByte(uint8_t data, bool_t rs);
static void API_display_writeNibble(uint8_t nibble, bool_t rs);

/* Function Implementations --------------------------------------------------*/

/**
 * @brief Sends a byte to the LCD display in nibble format.
 *
 * This function splits the byte into two nibbles (high and low) and sends them to the LCD display
 * using the `API_display_writeNibble` function. The byte is sent in two steps: first the high nibble
 * and then the low nibble. A delay is introduced after each step to ensure that the LCD processes
 * the data correctly.
 *
 * @param data The byte of data to be sent to the display.
 * @param rs A flag indicating whether the data is a command (rs = 0) or data (rs = 1).
 */
static void API_display_writeByte(uint8_t data, bool_t rs) {

	// Enviar el nibble alto al display LCD.
	// `data & 0xF0` asegura que solo el nibble alto sea enviado.
	// El parámetro `rs` se usa para definir el registro de selección (RS) en el display.
	API_display_writeNibble(data & 0xF0, rs);
	API_display_HAL_Delay(1);

	// Enviar el nibble bajo al display LCD.
	// `(data << 4) & 0xF0` asegura que solo el nibble bajo sea enviado.
	// El parámetro `rs` se usa para definir el registro de selección (RS) en el display.
	API_display_writeNibble((data << 4) & 0xF0, rs);
	API_display_HAL_Delay(1);
}

/**
 * @brief Sends a nibble to the LCD display.
 *
 * This function takes a 4-bit nibble, combines it with control bits, and sends it to the LCD display
 * using the I2C protocol. The function ensures that the correct control bits are set for either
 * data or command mode and toggles the enable bit to signal the LCD to read the nibble.
 *
 * @param nibble The 4-bit nibble to send to the display (higher 4 bits should be used).
 * @param rs A flag indicating whether the nibble is a command (rs = false) or data (rs = true).
 */
static void API_display_writeNibble(uint8_t nibble, bool_t rs) {

	// Prepare the data byte by masking the lower 4 bits and keeping only the higher 4 bits.
	uint8_t data_u = (nibble & 0xF0);

	// Set the RS (Register Select) bit according to the rs flag.
	if (rs == true) {
		data_u = data_u | LCD_RS;
	}

	// Array to hold the two bytes that will be sent to the LCD.
	uint8_t data_t[2];

	// Set the enable bit (EN) high, along with RS and data bits.
	data_t[0] = data_u | 0x04; // 0x04 sets the EN bit to high.

	// Set the enable bit (EN) low, along with RS and data bits.
	data_t[1] = data_u; // EN bit is cleared to low.

	// Transmit the prepared bytes to the LCD via I2C.
	API_display_HAL_I2C_Write(data_t, 2);

}
